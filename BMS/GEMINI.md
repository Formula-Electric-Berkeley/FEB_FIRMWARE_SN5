# Gemini AI Agent Guidelines for BMS Project

This document provides specialized guidelines for Google Gemini AI agents working on the BMS (Battery Management System) firmware project. These guidelines are tailored for Gemini's capabilities and development patterns.

## Overview for Gemini

The BMS project is a **safety-critical embedded system** requiring strict adherence to code boundaries. Gemini agents must distinguish between auto-generated code (never edit) and user code areas (safe to modify).

### Key Principles
- üîí **Never modify auto-generated STM32 code** outside user sections
- ‚úÖ **Use STM32CubeMX workflow** for hardware configuration
- üß™ **Always write tests** for new functionality
- üìù **Document changes clearly** for human developers

## Project Context and Architecture

### STM32F4xx Embedded System
- **Target**: STM32F446RE microcontroller
- **Framework**: STM32 HAL (Hardware Abstraction Layer)
- **Build System**: CMake with ARM GCC toolchain
- **Testing**: Google Test framework with HAL mocking

### Code Organization Map
```
BMS/
‚îú‚îÄ‚îÄ üü¢ Core/User/           # YOUR DEVELOPMENT AREA
‚îÇ   ‚îú‚îÄ‚îÄ Inc/               # User header files
‚îÇ   ‚îî‚îÄ‚îÄ Src/               # User implementation files
‚îú‚îÄ‚îÄ üî¥ Drivers/             # NEVER TOUCH - STM32 HAL
‚îú‚îÄ‚îÄ üü° Core/Inc/ & Core/Src/ # Generated code with user sections
‚îú‚îÄ‚îÄ üü¢ scripts/             # Development automation scripts
‚îÇ   ‚îú‚îÄ‚îÄ *.sh               # Unix shell scripts
‚îÇ   ‚îú‚îÄ‚îÄ *.bat              # Windows batch scripts
‚îÇ   ‚îú‚îÄ‚îÄ dev.sh/.bat        # Unified development workflow
‚îÇ   ‚îú‚îÄ‚îÄ submodule.sh/.bat  # Git submodule management
‚îÇ   ‚îî‚îÄ‚îÄ generate_can.sh/.bat # CAN library generation
‚îú‚îÄ‚îÄ üü° FEB_CAN_Library_SN4/ # Git submodule (see CAN section)
‚îÇ   ‚îú‚îÄ‚îÄ *_messages.py      # Python CAN message definitions
‚îÇ   ‚îú‚îÄ‚îÄ generate.py        # CAN generation script
‚îÇ   ‚îî‚îÄ‚îÄ gen/               # Auto-generated C/H files (NEVER EDIT)
‚îú‚îÄ‚îÄ üü¢ test/               # Full testing framework access
‚îú‚îÄ‚îÄ üü¢ .vscode/            # IDE configuration
‚îú‚îÄ‚îÄ üü¢ BMS.ioc            # Hardware configuration file
‚îî‚îÄ‚îÄ üü¢ *.md               # Documentation files
```

## Critical Safety Rules

### üö® PROHIBITED Actions (Could Break System)
```c
// ‚ùå NEVER edit STM32 HAL drivers
// File: Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_uart.c
void HAL_UART_Init(UART_HandleTypeDef *huart) {
    // This is auto-generated - editing breaks updates!
}

// ‚ùå NEVER edit generated peripheral initialization
// File: Core/Src/main.c (outside user sections)
void MX_USART2_UART_Init(void) {
    // Generated by STM32CubeMX - don't modify
}

// ‚ùå NEVER manually configure clock registers
RCC->APB1ENR |= RCC_APB1ENR_USART2EN;  // Use STM32CubeMX instead

// ‚ùå NEVER edit generated CAN library files
// File: FEB_CAN_Library_SN4/gen/feb_can.c
void can_message_pack(...) {
    // This is auto-generated from Python definitions - don't modify!
}
```

### ‚úÖ APPROVED Actions (Safe and Recommended)
```c
/* USER CODE BEGIN Includes */
#include "printf_redirect.h"      // ‚úÖ Add your includes
#include "custom_sensors.h"
/* USER CODE END Includes */

/* USER CODE BEGIN PV */
static uint32_t sensor_values[8]; // ‚úÖ Your variables
/* USER CODE END PV */

/* USER CODE BEGIN 0 */
void App_ProcessSensorData(void) {  // ‚úÖ Your functions
    for (int i = 0; i < 8; i++) {
        printf("Sensor %d: %lu\n", i, sensor_values[i]);
    }
}
/* USER CODE END 0 */
```

## STM32CubeMX Integration Workflow

### Hardware Configuration Process
When you need to add/modify hardware peripherals:

1. **Edit Configuration**: Modify `BMS.ioc` file
2. **Request Regeneration**: Inform user to regenerate
3. **Preserve User Code**: System preserves `/* USER CODE */` sections

### Example Configuration Change
```
I need to add I2C1 peripheral for sensor communication.

CHANGES MADE TO BMS.ioc:
- Enabled I2C1 on pins PB8 (SCL) and PB9 (SDA)
- Set I2C1 clock frequency to 100kHz
- Enabled I2C1 global interrupt

ACTION REQUIRED:
Please regenerate the code using STM32CubeMX:
1. Open BMS.ioc in STM32CubeMX
2. Click "GENERATE CODE"
3. Confirm overwrite when prompted
4. All USER CODE sections will be preserved

After regeneration, I2C1 will be properly initialized and ready for use.
```

### Hardware Configuration Best Practices
```c
// ‚úÖ CORRECT: Use generated peripheral handles
/* USER CODE BEGIN 0 */
HAL_StatusTypeDef App_I2C_ReadSensor(uint8_t addr, uint8_t* data) {
    return HAL_I2C_Master_Receive(&hi2c1, addr, data, 1, 1000);
    // hi2c1 is created by STM32CubeMX generation
}
/* USER CODE END 0 */

// ‚ùå INCORRECT: Don't manually initialize peripherals
void Manual_I2C_Init(void) {
    // Don't do this - use STM32CubeMX instead
    RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
    // ... manual register configuration
}
```

## FreeRTOS Integration for Gemini

### üö® Critical FreeRTOS Rules for Safety-Critical Systems

**Task Configuration Requirement:**
- ALL FreeRTOS tasks MUST be defined in `BMS.ioc` via STM32CubeMX
- NEVER manually create tasks with `xTaskCreate()` or `osThreadNew()`
- Task parameters (stack, priority, entry function) are configured through GUI

### Task Definition Workflow for Gemini

```
STEP-BY-STEP PROCESS:
1. Open BMS.ioc in STM32CubeMX
2. Navigate to Middleware ‚Üí FreeRTOS ‚Üí Queues
3. For ISR printf: Add "PrintfISRQueue" (10 items, 68 bytes each)
4. Navigate to Middleware ‚Üí FreeRTOS ‚Üí Tasks
5. Click "Add" to create new task
6. Configure:
   - Task Name: e.g., "BatteryMonitor"  
   - Priority: 0-56 (higher = higher priority)
   - Stack Size: 128-1024 words (not bytes!)
   - Entry Function: e.g., "BMS_MonitorTask"
7. For ISR printf: Add "PrintfISRTask" (Entry: "StartPrintfISRTask")
8. Generate code to update main.c
9. Implement task function in USER CODE sections
```

### Thread-Safe Printf Implementation

**‚úÖ SAFE: Use in FreeRTOS tasks**
```c
/* USER CODE BEGIN 0 */
void BMS_MonitorTask(void const * argument) {
    // Initialize printf system in main.c first!
    for(;;) {
        float voltage = BMS_ReadVoltage();
        float current = BMS_ReadCurrent();
        
        // Thread-safe printf with mutex protection
        debug_printf_safe("Battery: %.2fV, %.1fA\n", voltage, current);
        uart_printf_safe(&huart2, "SOC: %d%%\n", battery_soc);
        
        osDelay(1000);  // 1 second delay
    }
}
/* USER CODE END 0 */
```

**‚úÖ SAFE: Use in interrupt service routines**
```c
/* USER CODE BEGIN 0 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM2) {
        // ISR-safe printf using FreeRTOS queues
        uart_printf_isr("Timer overflow: %d\n", timer_count++);
    }
}
/* USER CODE END 0 */
```

**‚ùå UNSAFE: Don't use regular printf in multitasking**
```c
// DON'T DO THIS - causes resource conflicts and data corruption
void BadTask(void const * argument) {
    for(;;) {
        printf("This corrupts output!\n");  // NOT thread-safe!
        osDelay(100);
    }
}
```

### FreeRTOS Initialization Pattern

**Required setup in main.c:**
```c
/* USER CODE BEGIN 2 */
// CRITICAL: Initialize printf system before starting scheduler
printf_redirect_init();

// Test thread-safe printf
debug_printf_safe("FreeRTOS printf system ready\n");
/* USER CODE END 2 */

/* Start scheduler */
osKernelStart();
```

### Resource Management for Gemini

1. **Mutex Protection**: `*_safe()` functions use internal mutex (100ms timeout)
2. **ISR Queue**: `uart_printf_isr()` uses .ioc-defined PrintfISRQueue (10 messages, 68 bytes each)
3. **ISR Task**: Printf processing handled by .ioc-defined PrintfISRTask with StartPrintfISRTask entry
4. **Stack Optimization**: Static buffers minimize task stack usage  
5. **Error Handling**: Check return values for timeout detection

```c
/* USER CODE BEGIN 0 */
void SafePrintfExample(void) {
    int result = debug_printf_safe("Status: %d\n", system_status);
    if (result == -1) {
        // Handle mutex timeout or UART error
        Error_Handler();
    }
}
/* USER CODE END 0 */
```

### Testing FreeRTOS Features

Create comprehensive tests for thread safety:
```cpp
// FreeRTOS tests always available since project uses FreeRTOS
TEST(FreeRTOSTest, MutexProtection) {
    Mock_FreeRTOS_SetSemaphoreTakeResult(true);
    
    int result = debug_printf_safe("Thread-safe test");
    
    EXPECT_GT(result, 0);
    EXPECT_TRUE(Mock_FreeRTOS_GetSemaphoreTaken());
}
```

## CAN Library Management for Gemini

The project uses the FEB_CAN_Library_SN4 submodule to automatically generate C/H files from Python CAN message definitions. This system allows for maintainable CAN message management across multiple vehicle subsystems.

### CAN Library Architecture
```
FEB_CAN_Library_SN4/                    # Git submodule
‚îú‚îÄ‚îÄ bms_messages.py                     # üü¢ BMS CAN message definitions
‚îú‚îÄ‚îÄ pcu_messages.py                     # üü¢ PCU CAN message definitions  
‚îú‚îÄ‚îÄ dash_messages.py                    # üü¢ Dashboard message definitions
‚îú‚îÄ‚îÄ generate.py                         # üü° Python generation script
‚îî‚îÄ‚îÄ gen/                                # üî¥ Auto-generated (NEVER EDIT)
    ‚îú‚îÄ‚îÄ FEB_CAN.dbc                     # Generated DBC database
    ‚îú‚îÄ‚îÄ feb_can.c                       # Generated C source
    ‚îî‚îÄ‚îÄ feb_can.h                       # Generated C headers
```

### Python-to-C Generation Workflow

1. **Edit Python Definitions**: Modify message files (e.g., bms_messages.py)
2. **Update Submodule**: Run `./scripts/submodule.sh --update`
3. **Automatic Generation**: Scripts generate C/H files in gen/ directory
4. **Build Integration**: Generated files automatically included in CMake

### CAN Message Definition Example

```python
# FEB_CAN_Library_SN4/bms_messages.py
from cantools import Message, Signal

# Define BMS status message
bms_status = Message(
    frame_id=0x100,
    name='BMS_Status',
    length=8,
    signals=[
        Signal('voltage', start=0, length=16, scale=0.1, unit='V'),
        Signal('current', start=16, length=16, scale=0.1, offset=-3276.8, unit='A'),
        Signal('temperature', start=32, length=8, scale=1, offset=-40, unit='¬∞C'),
        Signal('fault_flags', start=40, length=8, scale=1, unit='')
    ]
)
```

### Using Generated CAN Library in Code

```c
/* USER CODE BEGIN Includes */
#include "feb_can.h"  // Generated CAN library
/* USER CODE END Includes */

/* USER CODE BEGIN 0 */
void App_SendBMSStatus(float voltage, float current, int8_t temp) {
    // Create message structure (generated from Python definition)
    bms_status_t status_msg = {
        .voltage = voltage,       // Automatically scaled by 0.1
        .current = current,       // Automatically scaled and offset
        .temperature = temp,      // Automatically offset by -40
        .fault_flags = 0x00      // No faults
    };
    
    // Pack message into CAN frame data (generated function)
    uint8_t can_data[8];
    int result = bms_status_pack(can_data, &status_msg, sizeof(can_data));
    
    if (result >= 0) {
        // Send via STM32 CAN HAL
        CAN_TxHeaderTypeDef tx_header = {
            .StdId = BMS_STATUS_FRAME_ID,  // Generated constant
            .RTR = CAN_RTR_DATA,
            .IDE = CAN_ID_STD,
            .DLC = 8,
            .TransmitGlobalTime = DISABLE
        };
        
        uint32_t tx_mailbox;
        HAL_StatusTypeDef status = HAL_CAN_AddTxMessage(&hcan1, &tx_header, 
                                                       can_data, &tx_mailbox);
        if (status == HAL_OK) {
            printf("BMS status sent: %.1fV, %.1fA, %d¬∞C\n", 
                   voltage, current, temp);
        }
    }
}

void App_ReceiveBMSStatus(uint8_t* can_data) {
    // Unpack received CAN message (generated function)
    bms_status_t received_status;
    int result = bms_status_unpack(&received_status, can_data, 8);
    
    if (result >= 0) {
        printf("Received BMS: %.1fV, %.1fA, %d¬∞C, flags:0x%02X\n",
               received_status.voltage,
               received_status.current, 
               received_status.temperature,
               received_status.fault_flags);
    }
}
/* USER CODE END 0 */
```

### Development Environment Setup

**Conda Environment (Recommended for Gemini)**:
```bash
# Create isolated environment
conda create -n feb_can python=3.8
conda activate feb_can
pip install cantools

# Verification
python -c "import cantools; print('CAN tools ready')"
```

**System Python (Alternative)**:
```bash
pip install cantools
python3 -c "import cantools; print('CAN tools ready')"
```

### CAN Library Management Scripts

The project provides comprehensive cross-platform scripts for CAN library management:

```bash
# Initialize submodule (after first clone)
./scripts/submodule.sh --init         # submodule.bat --init on Windows

# Update submodule and regenerate CAN files
./scripts/submodule.sh --update       # submodule.bat --update on Windows

# Check submodule status and versions
./scripts/submodule.sh --status       # submodule.bat --status on Windows

# Manually regenerate CAN library C/H files
./scripts/generate_can.sh             # generate_can.bat on Windows

# Show all submodule management options
./scripts/submodule.sh --help         # submodule.bat --help on Windows
```

### Rules for Gemini CAN Development

**‚úÖ SAFE TO EDIT**:
- Python message definition files (*_messages.py)
- User code that includes generated headers
- CAN-related user functions and logic

**üö® NEVER EDIT**:
- Generated C/H files in gen/ directory
- DBC files (auto-generated)
- The generate.py script (unless you understand the implications)

**üìã RECOMMENDED WORKFLOW**:
1. Modify Python CAN message definitions
2. Run `./scripts/submodule.sh --update` to regenerate
3. Include `feb_can.h` in your user code
4. Use generated pack/unpack functions
5. Test with unit tests using CAN message mocks

## Testing Framework for Gemini

### Test-Driven Development Approach
The project includes **26 unit tests** covering printf redirection and integration scenarios. When adding functionality, follow this pattern:

```cpp
// test/unit/test_new_feature.cpp
#include <gtest/gtest.h>

extern "C" {
    #include "new_feature.h"
    #include "stm32f4xx_hal.h"  // Mock HAL
}

class NewFeatureTest : public ::testing::Test {
protected:
    void SetUp() override {
        Mock_ResetAll();  // Reset hardware mocks
        // Test-specific setup
    }
    
    void TearDown() override {
        Mock_ResetAll();  // Clean up after test
    }
};

TEST_F(NewFeatureTest, BasicFunctionality_ValidInput_ReturnsSuccess) {
    // Arrange
    Mock_SetHALStatus(HAL_OK);
    int input_value = 42;
    
    // Act
    int result = feature_process_value(input_value);
    
    // Assert
    EXPECT_EQ(42, result);
    EXPECT_EQ(Mock_UART_GetBufferSize(), 0);  // No unexpected output
}

TEST_F(NewFeatureTest, ErrorHandling_HalError_ReturnsErrorCode) {
    // Test error conditions
    Mock_SetHALStatus(HAL_ERROR);
    
    int result = feature_process_value(10);
    
    EXPECT_EQ(-1, result);  // Error return code
}
```

### Mock System Usage
The testing framework provides comprehensive STM32 HAL mocks:

```cpp
// Configure mock behavior
Mock_SetADCValue(2048);           // Set ADC reading
Mock_SetHALStatus(HAL_TIMEOUT);   // Simulate timeout
Mock_UART_ClearBuffer();          // Clear UART buffer

// Execute function under test
your_function_using_hal();

// Verify interactions
uint8_t* uart_buffer = Mock_UART_GetBuffer();
uint32_t buffer_size = Mock_UART_GetBufferSize();
EXPECT_STREQ("Expected output", (char*)uart_buffer);
```

## Development Patterns for Gemini

### Error Handling Pattern
```c
/* USER CODE BEGIN 0 */
typedef enum {
    APP_SUCCESS = 0,
    APP_ERROR_INVALID_PARAM = -1,
    APP_ERROR_HAL_FAILURE = -2,
    APP_ERROR_TIMEOUT = -3
} AppResult_t;

AppResult_t App_ReadSensorValue(uint32_t* value) {
    if (value == NULL) {
        printf("ERROR: Invalid parameter\n");
        return APP_ERROR_INVALID_PARAM;
    }
    
    uint32_t adc_reading;
    HAL_StatusTypeDef status = HAL_ADC_Start(&hadc1);
    if (status != HAL_OK) {
        printf("ERROR: ADC start failed: %d\n", status);
        return APP_ERROR_HAL_FAILURE;
    }
    
    status = HAL_ADC_PollForConversion(&hadc1, 100);
    if (status == HAL_TIMEOUT) {
        printf("ERROR: ADC conversion timeout\n");
        HAL_ADC_Stop(&hadc1);
        return APP_ERROR_TIMEOUT;
    }
    
    *value = HAL_ADC_GetValue(&hadc1);
    HAL_ADC_Stop(&hadc1);
    
    printf("Sensor value: %lu\n", *value);
    return APP_SUCCESS;
}
/* USER CODE END 0 */
```

### Initialization Sequence Pattern
```c
/* USER CODE BEGIN 2 */
// Application initialization after STM32CubeMX setup
printf("BMS System Starting...\n");

// Initialize user modules
if (App_InitializeSensors() != APP_SUCCESS) {
    printf("ERROR: Sensor initialization failed\n");
    Error_Handler();
}

if (App_InitializeDataLogger() != APP_SUCCESS) {
    printf("ERROR: Data logger initialization failed\n");
    Error_Handler();
}

printf("BMS System Ready\n");
/* USER CODE END 2 */
```

### Main Loop Pattern
```c
/* USER CODE BEGIN WHILE */
while (1) {
    /* USER CODE BEGIN 3 */
    
    // Process sensor data
    if (App_ProcessSensors() != APP_SUCCESS) {
        printf("WARNING: Sensor processing error\n");
    }
    
    // Handle communication
    App_ProcessUARTCommands();
    
    // Update system state
    App_UpdateSystemStatus();
    
    // Brief delay
    HAL_Delay(100);
    
    /* USER CODE END 3 */
}
/* USER CODE END WHILE */
```

## Building and Testing Commands

### Test Execution
```bash
# Run all 26 unit tests
./run_tests.sh

# Cross-platform VSCode runner
./run_vscode_tests.sh          # Unix/macOS
run_vscode_tests.bat           # Windows

# Run specific test suite
./run_vscode_tests.sh --gtest_filter="PrintfRedirectTest.*"

# Debug specific test
./run_vscode_tests.sh --gtest_filter="*SpecificTestName*"
```

### Build Verification
```bash
# Test build (always works - uses system compiler)
cd test/build
cmake .. && cmake --build .

# Firmware build (requires ARM toolchain)
mkdir build && cd build  
cmake .. -DCMAKE_TOOLCHAIN_FILE=../cmake/gcc-arm-none-eabi.cmake
make  # Produces BMS.elf, BMS.hex, BMS.bin
```

## Gemini-Specific Best Practices

### Code Analysis Approach
1. **Understand Context**: Read existing code patterns first
2. **Identify Boundaries**: Locate user code sections
3. **Plan Tests**: Design test cases before implementation
4. **Implement Incrementally**: Small, testable changes
5. **Verify Integration**: Run full test suite

### Communication Style
```
ANALYSIS:
I need to add PWM functionality for LED brightness control.

HARDWARE CHANGES REQUIRED:
- Configure TIM2 as PWM generator
- Enable PA5 as TIM2_CH1 (PWM output)

IMPLEMENTATION PLAN:
1. Modify BMS.ioc to add TIM2 PWM configuration
2. Add user code for PWM control functions
3. Create unit tests for PWM functionality
4. Update documentation

ACTION NEEDED FROM USER:
Please regenerate code after I modify BMS.ioc file.
```

### Error Prevention Checklist
- [ ] Changes only in user code areas?
- [ ] STM32CubeMX used for hardware changes?
- [ ] Unit tests written for new functionality?
- [ ] Existing tests still pass?
- [ ] Error handling implemented?
- [ ] Documentation updated?

## Advanced Gemini Techniques

### Multi-Module Architecture
```c
// Core/User/Inc/sensor_manager.h
#ifndef SENSOR_MANAGER_H
#define SENSOR_MANAGER_H

#include "stm32f4xx_hal.h"

typedef struct {
    uint32_t voltage;
    uint32_t current;  
    int16_t temperature;
    bool valid;
} SensorData_t;

typedef enum {
    SENSOR_OK,
    SENSOR_ERROR_TIMEOUT,
    SENSOR_ERROR_INVALID_DATA
} SensorStatus_t;

SensorStatus_t Sensor_ReadAll(SensorData_t* data);
void Sensor_PrintStatus(const SensorData_t* data);

#endif
```

```c
// Core/User/Src/sensor_manager.c
#include "sensor_manager.h"
#include "printf_redirect.h"

SensorStatus_t Sensor_ReadAll(SensorData_t* data) {
    if (data == NULL) return SENSOR_ERROR_INVALID_DATA;
    
    // Read voltage
    HAL_StatusTypeDef status = HAL_ADC_Start(&hadc1);
    if (status != HAL_OK) return SENSOR_ERROR_TIMEOUT;
    
    status = HAL_ADC_PollForConversion(&hadc1, 100);
    if (status != HAL_OK) {
        HAL_ADC_Stop(&hadc1);
        return SENSOR_ERROR_TIMEOUT;
    }
    
    data->voltage = HAL_ADC_GetValue(&hadc1);
    HAL_ADC_Stop(&hadc1);
    
    // Additional sensor readings...
    data->valid = true;
    return SENSOR_OK;
}

void Sensor_PrintStatus(const SensorData_t* data) {
    if (data && data->valid) {
        printf("V:%lu mV, I:%lu mA, T:%d¬∞C\n", 
               data->voltage, data->current, data->temperature);
    } else {
        printf("Sensor data invalid\n");
    }
}
```

### State Machine Implementation
```c
/* USER CODE BEGIN PV */
typedef enum {
    SYSTEM_INIT,
    SYSTEM_CALIBRATING, 
    SYSTEM_MONITORING,
    SYSTEM_FAULT,
    SYSTEM_SHUTDOWN
} SystemState_t;

static SystemState_t system_state = SYSTEM_INIT;
static uint32_t state_timer = 0;
/* USER CODE END PV */

/* USER CODE BEGIN 0 */
void App_StateMachineUpdate(void) {
    switch (system_state) {
        case SYSTEM_INIT:
            printf("System initializing...\n");
            if (App_InitializeHardware() == APP_SUCCESS) {
                system_state = SYSTEM_CALIBRATING;
                state_timer = HAL_GetTick();
            }
            break;
            
        case SYSTEM_CALIBRATING:
            if (App_CalibrateSystem()) {
                printf("Calibration complete\n");
                system_state = SYSTEM_MONITORING;
            } else if (HAL_GetTick() - state_timer > 10000) {
                printf("Calibration timeout\n");
                system_state = SYSTEM_FAULT;
            }
            break;
            
        case SYSTEM_MONITORING:
            SensorData_t data;
            if (Sensor_ReadAll(&data) == SENSOR_OK) {
                Sensor_PrintStatus(&data);
                App_ProcessSensorData(&data);
            } else {
                system_state = SYSTEM_FAULT;
            }
            break;
            
        case SYSTEM_FAULT:
            printf("System fault detected\n");
            App_HandleFault();
            break;
            
        case SYSTEM_SHUTDOWN:
            App_SafeShutdown();
            break;
    }
}
/* USER CODE END 0 */
```

## Development Automation Tools

### Automated Script System

Gemini agents should leverage the comprehensive script automation available in the project:

#### Task-Specific Scripts
```bash
# Clean all build artifacts
./scripts/clean.sh               # clean.bat on Windows

# Build STM32 firmware
./scripts/build.sh               # build.bat on Windows

# Flash firmware to connected device
./scripts/flash.sh               # flash.bat on Windows

# Run complete unit test suite
./scripts/test.sh                # test.bat on Windows
```

#### Submodule and CAN Library Management
```bash
# Initialize submodules (after first clone)
./scripts/submodule.sh --init    # submodule.bat --init on Windows

# Update submodules and regenerate CAN library
./scripts/submodule.sh --update  # submodule.bat --update on Windows

# Check submodule status
./scripts/submodule.sh --status  # submodule.bat --status on Windows

# Generate CAN library C/H files from Python definitions  
./scripts/generate_can.sh        # generate_can.bat on Windows
```

#### Workflow Automation
```bash
# Show all development workflow options
./scripts/dev.sh --help          # dev.bat --help on Windows

# Complete development cycle (includes submodule update)
./scripts/dev.sh --all           # dev.bat --all on Windows

# Development mode (no hardware flashing)
./scripts/dev.sh --dev           # dev.bat --dev on Windows

# Quick development workflows
./scripts/dev.sh -bf             # dev.bat -bf on Windows (Build and flash)
./scripts/dev.sh -bt             # dev.bat -bt on Windows (Build and test)
./scripts/dev.sh -cbt            # dev.bat -cbt on Windows (Clean, build, and test)

# Preview mode (show commands without execution)
./scripts/dev.sh --dry-run --all # dev.bat --dry-run --all on Windows
```

#### Cross-Platform Script Features
**Full Script Equivalency**: All `.sh`/`.bat` pairs provide identical functionality:
- ‚úÖ Same command-line arguments (-c, --clean, -b, --build, etc.)
- ‚úÖ Identical error handling and exit codes
- ‚úÖ Consistent help documentation and output formatting
- ‚úÖ File size reporting in build and flash operations
- ‚úÖ Enhanced error messages with troubleshooting advice

**Enhanced CAN Library Integration**:
- üîÑ Automatic C/H file generation from Python CAN message definitions
- üêç Conda environment detection with system Python fallback
- üì¶ Dependency checking for `cantools` package with installation guidance
- üîß Generated files automatically included in CMake build system

#### Integration Benefits for Gemini
- **Consistency**: All developers and AI agents use the same workflows
- **Error Handling**: Scripts include comprehensive error checking
- **Cross-platform**: Works on Windows, macOS, and Linux
- **VSCode Integration**: Available as VSCode tasks for GUI users

### Recommended Development Pattern for Gemini
1. **Start with clean state**: `./scripts/dev.sh -c`
2. **Implement feature**: Modify user code areas
3. **Build and test**: `./scripts/dev.sh -bt`
4. **Deploy to hardware**: `./scripts/dev.sh -f` (if needed)
5. **Final validation**: `./scripts/dev.sh --all`

## Integration with VSCode

### Development Workflow
1. **Configure Environment**: Select "Tests" configuration for test development
2. **Develop Features**: Write code in user sections
3. **Create Tests**: Add comprehensive test coverage
4. **Debug**: Use F5 debugging with breakpoints
5. **Validate**: Run full test suite

### VSCode Tasks for Gemini
- `Cmd+Shift+P` ‚Üí "Tasks: Run Task" ‚Üí "Build and Run Tests"
- `F5` ‚Üí Select debug configuration for platform
- `Cmd+Shift+P` ‚Üí "C/C++: Select a Configuration" ‚Üí Switch between STM32/Tests

## Troubleshooting Guide for Gemini

### Common Issues and Solutions

**Build Errors:**
```
error: 'HAL_UART_Transmit' was not declared
```
Solution: Add `#include "stm32f4xx_hal.h"` in user code section

**Test Failures:**
```
Expected: HAL_OK, Actual: HAL_ERROR
```  
Solution: Check mock configuration - `Mock_SetHALStatus(HAL_OK)`

**Generated Code Conflicts:**
```
error: redefinition of function
```
Solution: Move custom code to user sections only

### Debug Strategies
1. **Use Printf**: Output goes to UART (captured in tests)
2. **Mock Verification**: Check `Mock_UART_GetBuffer()` contents
3. **Test Isolation**: Run single tests to isolate issues
4. **Code Review**: Verify user code boundaries respected

## Summary Guidelines for Gemini

### Development Checklist
- [ ] Identify user code areas before editing
- [ ] Use STM32CubeMX for hardware configuration
- [ ] Write unit tests for all new functionality
- [ ] Implement proper error handling
- [ ] Document code changes clearly
- [ ] Run test suite before completing tasks

### Code Quality Standards
- Functions should be focused and testable
- Error conditions must be handled gracefully
- User interfaces should be documented
- State changes should be logged
- Resource cleanup should be implemented

### Communication Protocol
1. **Explain Changes**: What you're implementing and why
2. **Show Code Boundaries**: Point out user vs generated sections
3. **Request Actions**: When STM32CubeMX regeneration needed
4. **Verify Results**: Confirm tests pass after changes

---

**Gemini Success Pattern**: Analyze ‚Üí Plan ‚Üí Test ‚Üí Implement ‚Üí Verify ‚Üí Document