# Claude AI Agent Guidelines for BMS Project

This document provides specific guidelines for Claude AI agents working on the BMS firmware project. Following these guidelines ensures proper development practices and maintains code integrity.

## Quick Reference

### ✅ ALLOWED Actions
- Edit files in `Core/User/Inc/` and `Core/User/Src/`
- Modify code within `/* USER CODE BEGIN */` and `/* USER CODE END */` blocks
- Edit `.ioc` files and request user to regenerate code
- Create new test files in `test/unit/`
- Modify test configuration files
- Update documentation files (*.md)
- Edit CMake files in user directories
- Modify VSCode configuration files
- **Edit all development scripts in `scripts/` directory**
- **Modify Python CAN message definitions in `FEB_CAN_Library_SN4/`**
- **Run CAN library generation scripts**
- **Update git submodules**

### ❌ FORBIDDEN Actions
- Edit auto-generated code outside `/* USER CODE */` sections
- Modify files in `Drivers/` directory
- Change STM32 HAL driver implementations
- Edit generated CMake files (except user-added sections)
- Modify auto-generated headers without user code sections
- Directly change generated startup or linker files
- **Edit generated CAN library files in `FEB_CAN_Library_SN4/gen/`**
- **Manually modify `.git/` directory or submodule configuration**

## Project Structure and Permissions

### User-Editable Areas
```
BMS/
├── Core/User/              ✅ FULL EDIT ACCESS
│   ├── Inc/               ✅ User headers
│   └── Src/               ✅ User source code
├── test/                  ✅ FULL EDIT ACCESS
│   ├── unit/              ✅ Add/modify test files
│   ├── mocks/             ✅ Update mocks as needed
│   └── CMakeLists.txt     ✅ Test configuration
├── scripts/               ✅ FULL EDIT ACCESS
│   ├── *.sh               ✅ Unix shell scripts
│   ├── *.bat              ✅ Windows batch scripts
│   └── Cross-platform development automation
├── FEB_CAN_Library_SN4/   ⚠️  SUBMODULE (see CAN library section)
│   ├── Python files      ✅ Edit Python message definitions
│   └── gen/               ❌ Auto-generated C/H files
├── .vscode/               ✅ IDE configuration
├── *.md                   ✅ Documentation files
├── BMS.ioc               ✅ STM32CubeMX config (see special rules)
└── User sections in generated files ✅ See section below
```

### Auto-Generated (RESTRICTED)
```
BMS/
├── Core/Inc/              ❌ EXCEPT user code sections
├── Core/Src/              ❌ EXCEPT user code sections  
├── Drivers/               ❌ NEVER EDIT
├── Generated CMakeLists.txt ❌ EXCEPT user sections
└── Startup files          ❌ NEVER EDIT
```

## Working with STM32CubeMX Generated Code

### User Code Sections
Look for these patterns in generated files:
```c
/* USER CODE BEGIN Includes */
// ✅ ADD YOUR INCLUDES HERE
/* USER CODE END Includes */

/* USER CODE BEGIN PV */
// ✅ ADD YOUR PRIVATE VARIABLES HERE  
/* USER CODE END PV */

/* USER CODE BEGIN 0 */
// ✅ ADD YOUR CODE HERE
/* USER CODE END 0 */
```

### STM32CubeMX Configuration Workflow
When modifying hardware configuration:

1. **Edit .ioc File**: Make changes to `BMS.ioc`
2. **Request Regeneration**: Tell the user:
   ```
   I've modified the BMS.ioc file. Please open it in STM32CubeMX 
   and regenerate the code to apply these changes:
   
   1. Open BMS.ioc in STM32CubeMX
   2. Click "GENERATE CODE" 
   3. Confirm overwrite when prompted
   4. The generator will preserve all USER CODE sections
   ```
3. **Never Bypass**: Don't try to manually edit generated code instead

### Example .ioc Modifications
```c
// ✅ CORRECT: Modify .ioc file, then request regeneration
// File: BMS.ioc
// Add UART3 configuration
Mcu.IP0=UART3
UART3.BaudRate=115200

// ❌ INCORRECT: Don't manually add UART3 init code
// This should be generated by STM32CubeMX
```

## Building and Testing

### Test Development Guidelines
When adding tests:

1. **Create Test Files**: Add to `test/unit/test_module_name.cpp`
2. **Update CMakeLists**: Add new source files to `test/CMakeLists.txt`
3. **Use Mocks**: Leverage existing STM32 HAL mocks
4. **Verify Tests**: Always run tests after changes

### Development Scripts

The project includes a comprehensive cross-platform script system for all development tasks. Each script has both Unix shell (`.sh`) and Windows batch (`.bat`) equivalents with identical functionality.

#### Core Individual Scripts
```bash
# Clean build directories
./scripts/clean.sh          # clean.bat on Windows

# Build STM32 firmware  
./scripts/build.sh           # build.bat on Windows

# Flash firmware to device
./scripts/flash.sh           # flash.bat on Windows

# Run unit tests
./scripts/test.sh            # test.bat on Windows
```

#### Submodule and CAN Library Management
```bash
# Manage git submodules (with automatic CAN library generation)
./scripts/submodule.sh --help       # submodule.bat --help on Windows
./scripts/submodule.sh --update     # Update submodule and regenerate CAN files
./scripts/submodule.sh --status     # Check submodule status

# Generate CAN library C/H files from Python definitions
./scripts/generate_can.sh --help    # generate_can.bat --help on Windows  
./scripts/generate_can.sh           # Generate feb_can.c and feb_can.h
```

#### Unified Development Workflow Script
```bash
# Show all available options
./scripts/dev.sh --help             # dev.bat --help on Windows

# Complete development cycle (includes submodule updates)
./scripts/dev.sh --all              # submodule → clean → build → test → flash

# Development mode (no hardware flashing)
./scripts/dev.sh --dev              # submodule → clean → build → test

# Individual operations
./scripts/dev.sh -s                 # Update submodules only
./scripts/dev.sh -bf                # Build then flash
./scripts/dev.sh -bt                # Build then test
./scripts/dev.sh -cbt               # Clean, build, then test

# Dry run mode (preview actions)
./scripts/dev.sh --dry-run --all    # See what would be executed
```

#### Legacy Scripts (Still Available)
```bash
# Legacy combined test runner
./scripts/run_tests.sh       # run_tests.bat on Windows

# Quick VSCode test runner (Unix only)
./run_vscode_tests.sh
```

#### Script Features and Consistency

**Cross-Platform Equivalency**: All script pairs (.sh/.bat) provide identical functionality with:
- ✅ Consistent command-line arguments
- ✅ Identical error handling and exit codes  
- ✅ Uniform help documentation
- ✅ Same file operations and output formatting

**Automatic CAN Library Integration**: 
- Submodule updates automatically regenerate C/H files from Python definitions
- Conda environment support with automatic detection
- Fallback to system Python if Conda unavailable
- Generated files: `FEB_CAN_Library_SN4/gen/feb_can.{c,h,dbc}`

**Enhanced Error Handling**:
- Comprehensive error checking on all file operations
- Clear error messages with actionable troubleshooting advice
- Proper exit codes for CI/CD integration
- Graceful failure handling with informative tips

**Requirements Auto-Detection**:
- Automatic build tool detection (Ninja, Make, etc.)
- Compiler verification (GCC, Clang, MSVC)
- STM32 programmer availability checking
- Python/Conda environment validation

### Test File Template
```cpp
#include <gtest/gtest.h>

extern "C" {
    #include "your_module.h"
    #include "stm32f4xx_hal.h"
}

class YourModuleTest : public ::testing::Test {
protected:
    void SetUp() override {
        Mock_ResetAll();
        // Test setup
    }
    
    void TearDown() override {
        Mock_ResetAll();
    }
};

TEST_F(YourModuleTest, FeatureName_Scenario) {
    // Arrange
    Mock_SetHALStatus(HAL_OK);
    
    // Act
    int result = your_function();
    
    // Assert
    EXPECT_EQ(EXPECTED_VALUE, result);
}
```

### FreeRTOS Test Template
```cpp
// FreeRTOS tests - Always available since project uses FreeRTOS
class YourModuleFreeRTOSTest : public ::testing::Test {
protected:
    void SetUp() override {
        Mock_ResetAll();
        Mock_UART_ClearBuffer();
        Mock_FreeRTOS_Reset();
        
        // Initialize FreeRTOS mocks
        Mock_FreeRTOS_SetMutexCreateResult(true);
        Mock_FreeRTOS_SetQueueCreateResult(true);
        Mock_FreeRTOS_SetSemaphoreTakeResult(true);
    }
    
    void TearDown() override {
        Mock_ResetAll();
        Mock_FreeRTOS_Reset();
    }
};

TEST_F(YourModuleFreeRTOSTest, ThreadSafety_MutexProtection) {
    your_module_init();  // Initialize your module
    
    int result = your_threadsafe_function();
    
    EXPECT_GT(result, 0);
    EXPECT_TRUE(Mock_FreeRTOS_GetSemaphoreTaken());
    EXPECT_TRUE(Mock_FreeRTOS_GetSemaphoreGiven());
    
    your_module_deinit();
}

TEST_F(YourModuleFreeRTOSTest, ISRSafety_QueueUsage) {
    your_module_init();
    
    Mock_FreeRTOS_SetQueueSendFromISRResult(true);
    
    int result = your_isr_safe_function();
    
    EXPECT_GT(result, 0);
    EXPECT_TRUE(Mock_FreeRTOS_GetQueueSentFromISR());
    
    your_module_deinit();
}
```

## STM32 Development Patterns

### FreeRTOS Integration

**Task Definition Workflow:**
```
1. Define FreeRTOS tasks and queues in BMS.ioc using STM32CubeMX:
   - Open BMS.ioc → FreeRTOS → Tasks
   - Add/configure tasks with stack size, priority, entry function
   - For ISR printf: Add "PrintfISRQueue" (10 items, 68 bytes)
   - For ISR printf: Add "PrintfISRTask" (Entry: "StartPrintfISRTask")
   - Generate code to update main.c task creation

2. Initialize printf system in main.c USER CODE section:
   /* USER CODE BEGIN 2 */
   printf_redirect_init();  // Setup mutexes (queue/task from .ioc)
   /* USER CODE END 2 */
```

**Thread-Safe Printf Usage:**
```c
// ✅ GOOD: Use thread-safe functions in FreeRTOS tasks
void MyTaskFunction(void *pvParameters) {
    for (;;) {
        debug_printf_safe("Task %s running\n", pcTaskGetName(NULL));
        uart_printf_safe(&huart2, "Sensor: %d\n", sensor_reading);
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

// ✅ GOOD: Use ISR-safe functions in interrupts
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM2) {
        uart_printf_isr("Timer interrupt: %d\n", counter++);
    }
}

// ❌ BAD: Don't use regular printf in FreeRTOS tasks - not thread-safe
void BadTaskFunction(void *pvParameters) {
    printf("This could corrupt output!\n");  // Resource conflict risk
}
```

**FreeRTOS Resource Management:**
```c
// ✅ GOOD: Always initialize printf system before using
void main(void) {
    /* STM32 HAL initialization */
    
    /* USER CODE BEGIN 2 */
    printf_redirect_init();  // Required for thread-safe printf
    /* USER CODE END 2 */
    
    /* Start scheduler */
    osKernelStart();
}

// ✅ GOOD: Handle timeout scenarios gracefully
int result = debug_printf_safe("Status: %d\n", status);
if (result == -1) {
    // Mutex timeout or other error - handle appropriately
    // Don't block indefinitely in critical sections
}
```

### Printf Redirection
The project includes printf→UART redirection with FreeRTOS thread safety:
```c
// ✅ Use thread-safe printf in FreeRTOS tasks
debug_printf_safe("Debug: value = %d\n", sensor_value);

// ✅ Use ISR-safe printf in interrupt handlers
uart_printf_isr("ISR: interrupt count = %d\n", isr_count);

// ✅ The redirection is handled in printf_redirect.c
// Thread safety and ISR safety are implemented and tested
```

### Error Handling Pattern
```c
// ✅ GOOD: Always check HAL return values
HAL_StatusTypeDef status = HAL_UART_Transmit(&huart2, data, len, 1000);
if (status != HAL_OK) {
    // Handle error appropriately
    printf("UART Error: %d\n", status);
    return ERROR_UART_FAIL;
}

// ❌ BAD: Don't ignore return values
HAL_UART_Transmit(&huart2, data, len, 1000); // Unchecked!
```

### User Code Organization
```c
// ✅ GOOD: Keep user code in designated areas
/* USER CODE BEGIN Includes */
#include "printf_redirect.h"
#include "custom_module.h"
/* USER CODE END Includes */

/* USER CODE BEGIN PV */
static uint32_t sensor_readings[16];
static bool system_initialized = false;
/* USER CODE END PV */

/* USER CODE BEGIN 0 */
void Custom_InitializeSystem(void) {
    system_initialized = true;
    printf("System initialized\n");
}
/* USER CODE END 0 */
```

## CAN Library Management

The project uses the FEB_CAN_Library_SN4 submodule for CAN message definitions. This system automatically generates C/H files from Python message definitions.

### CAN Library Workflow

```bash
# 1. Update submodule to latest CAN definitions (automatic generation)
./scripts/submodule.sh --update

# 2. Manually regenerate CAN library files (if needed)
./scripts/generate_can.sh

# 3. Check submodule status
./scripts/submodule.sh --status
```

### Generated Files (DO NOT EDIT)
```
FEB_CAN_Library_SN4/gen/
├── feb_can.c         # Generated CAN message functions
├── feb_can.h         # Generated CAN message headers  
└── FEB_CAN.dbc       # Generated DBC database file
```

### Python CAN Definitions (EDITABLE)
```
FEB_CAN_Library_SN4/
├── bms_messages.py           # BMS CAN message definitions
├── pcu_messages.py           # PCU CAN message definitions
├── dash_messages.py          # Dashboard message definitions
├── generate.py               # Main generation script
└── Other *_messages.py files
```

### CAN Integration Requirements

**Conda Environment (Recommended)**:
```bash
# Create environment
conda create -n feb_can python=3.8
conda activate feb_can
pip install cantools

# Scripts automatically detect and use feb_can environment
```

**System Python (Alternative)**:
```bash
pip install cantools
# Scripts automatically fall back to system Python
```

### CAN Library Usage in Code

```c
// Include generated CAN library
#include "feb_can.h"

// Example: Encode a BMS status message
uint8_t can_data[8];
bms_state_t bms_status = {
    .voltage = 400,  // 400V
    .current = 25,   // 25A
    .temperature = 45 // 45°C
};

int result = bms_state_pack(can_data, &bms_status, sizeof(can_data));
if (result >= 0) {
    // Send CAN message with ID BMS_STATE_FRAME_ID
    // HAL_CAN_Transmit(...);
}
```

### Automatic Integration

The CAN library is automatically integrated into the build system:
- ✅ CMake includes `feb_can.c` in compilation
- ✅ Headers available via `#include "feb_can.h"`  
- ✅ Unit tests can access CAN message functions
- ✅ Submodule updates trigger automatic regeneration

## Common Tasks and Patterns

### Adding New Functionality

1. **Create User Module**:
   ```c
   // Core/User/Inc/new_feature.h
   #ifndef NEW_FEATURE_H
   #define NEW_FEATURE_H
   // Interface declarations
   #endif
   
   // Core/User/Src/new_feature.c  
   #include "new_feature.h"
   // Implementation
   ```

2. **Add Tests**:
   ```cpp
   // test/unit/test_new_feature.cpp
   // Comprehensive test coverage
   ```

3. **Update Build**:
   ```cmake
   # test/CMakeLists.txt - add new source file
   set(TEST_SOURCES
       unit/test_printf_redirect.cpp
       unit/test_new_feature.cpp
       ../Core/User/Src/printf_redirect.c
       ../Core/User/Src/new_feature.c
       mocks/stm32f4xx_hal.c
   )
   ```

### Peripheral Configuration

1. **Use STM32CubeMX**: Don't manually configure peripherals
   ```
   I need to add SPI peripheral support. I'll modify the BMS.ioc 
   configuration file. Please regenerate the code using STM32CubeMX
   after I make these changes.
   ```

2. **Add User Code**: Put your application logic in user sections
   ```c
   /* USER CODE BEGIN 2 */
   Custom_SPI_Initialize();
   /* USER CODE END 2 */
   ```

### Debugging and Logging

```c
/* USER CODE BEGIN Includes */
#include "printf_redirect.h"
/* USER CODE END Includes */

/* USER CODE BEGIN 0 */
void Debug_LogSensorData(float voltage, float current) {
    printf("Sensors: V=%.2f, I=%.2f\n", voltage, current);
}
/* USER CODE END 0 */
```

## Mock System Usage

### Available Mocks
The test framework provides mocks for:
- **UART Functions**: `HAL_UART_Transmit`, `HAL_UART_Receive`
- **ADC Functions**: `HAL_ADC_Start`, `HAL_ADC_GetValue`
- **General HAL**: Configurable return status

### Mock Usage Examples
```cpp
TEST_F(MyTest, UART_Communication) {
    // Setup mock
    Mock_SetHALStatus(HAL_OK);
    Mock_UART_ClearBuffer();
    
    // Test function that uses UART
    my_uart_function("test data");
    
    // Verify mock interactions
    uint8_t* buffer = Mock_UART_GetBuffer();
    EXPECT_STREQ("test data", (char*)buffer);
}

TEST_F(MyTest, ADC_Reading) {
    // Setup mock ADC value
    Mock_SetADCValue(2048);
    
    // Test ADC reading function
    uint32_t reading = my_adc_read_function();
    
    // Verify result
    EXPECT_EQ(2048, reading);
}
```

## Error Handling and Recovery

### When Build Fails
1. **Check User Code**: Ensure your changes are in proper user sections
2. **Verify Syntax**: Check for missing headers, syntax errors
3. **Clean Rebuild**: `rm -rf build test/build && ./run_tests.sh`

### When Tests Fail
1. **Run Specific Test**: `./run_vscode_tests.sh --gtest_filter="TestName.*"`
2. **Debug with VSCode**: Set breakpoints and use F5 debug
3. **Check Mock Setup**: Ensure mocks are properly configured

### Code Generation Issues
If STM32CubeMX regeneration causes problems:
1. **Backup User Code**: User sections should be preserved
2. **Check .ioc File**: Verify configuration is correct
3. **Manual Recovery**: Copy user code sections if needed

## VSCode Integration

### Configuration Switching
- **STM32 Configuration**: For firmware development
- **Tests Configuration**: For unit test development
- Switch: `Cmd+Shift+P` → "C/C++: Select a Configuration"

### Tasks Available
- **Build and Run Tests**: Complete test build and execution
- **Debug Tests**: Debug test files with breakpoints
- **Clean Build**: Reset build environment

### Debugging
```json
// Set breakpoints in test files or source code
// Press F5 and select appropriate debug configuration
// Step through code execution and inspect variables
```

## Best Practices Summary

### Code Quality
- ✅ Always write tests for new functionality
- ✅ Use existing patterns and conventions
- ✅ Check function return values
- ✅ Add meaningful error messages
- ✅ Document complex logic

### Project Integrity  
- ✅ Respect auto-generated vs user code boundaries
- ✅ Use STM32CubeMX for hardware configuration
- ✅ Keep user code in designated directories
- ✅ Preserve existing test coverage
- ✅ Follow established naming conventions

### Development Workflow
1. **Understand Requirements**: Clarify what needs to be implemented
2. **Plan Changes**: Identify which files need modification
3. **Implement**: Write code in appropriate user areas
4. **Test**: Create comprehensive unit tests
5. **Verify**: Run full test suite and check build
6. **Document**: Update relevant documentation

## Troubleshooting Quick Reference

| Issue | Solution |
|-------|----------|
| Build fails | Check user code sections, clean rebuild |
| Tests fail | Debug specific tests, check mock setup |
| IntelliSense errors | Switch VSCode configuration |  
| Can't find headers | Verify include paths and user code placement |
| STM32 peripherals don't work | Use .ioc file, don't manually configure |
| Generated code conflicts | Put custom code in user sections only |

## Examples and Templates

See existing code in:
- `Core/User/Src/printf_redirect.c` - Example user module
- `test/unit/test_printf_redirect.cpp` - Example test file
- Generated files with `/* USER CODE */` sections - Integration examples

---

**Remember**: When in doubt, ask the user for clarification rather than making assumptions about code generation or hardware configuration.